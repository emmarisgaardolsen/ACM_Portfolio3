---
title: "main"
author: "EOL"
date: "2024-03-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#  Load the packages
```{r}
pacman::p_load(cmdstanr,
               tidyverse,
               ggplot2,
               dplyr,
               gridExtra,
               here,
               posterior,
               brms,
               tidybayes,
               patchwork)
```


# Implement simple Bayes model 


# Implement weighted Bayes model

By adjusting the weights `w1` and `w2` from a [0,1] scale to a [-1,1] scale, the function allows for a nuanced interpretation of weights. Weights greater than 0.5 enhance the influence of their respective source, while weights less than 0.5 reduce it. A weight of 0.5 effectively neutralizes the source's impact, acting as a pivot point.

The `bias` term allows for adjusting the baseline `likelihood` of the outcome

`Source1` and `Source2` are scaled through the `logit_scaled function` and then  the adjusted weights are applied. This ensures that the contribution of each source to the final outcome is multiplicatively modulated. The final outcome is calculated through an `inv_logit_scaled` transformation of the weighted sum of the sources (after applying the bias). This ensures that the outcome is on a [0,1] scale, i.e. back to probability space. 


```{r}

WeightedBayes_f <- function(bias, Source1, Source2, w1, w2){
  
  w1 <- (w1 - 0.5)*2 # scale to -1 to 1, weights > 0.5 enhance influence of source
  w2 <- (w2 - 0.5)*2 # scale to -1 to 1, weights < 0.5 reduce influence of source
  
  outcome <- inv_logit_scaled(bias + w1*logit_scaled(Source1) + w2*logit_scaled(Source2))
  
  return(outcome)
}

```


```{r}

# global params
n_trials <- 150
feedback_options <- c(-3,-2,0,2,3) # feedback options 
w1 <- 0.6 # weight for own source
w2 <- 0.9 # weight for other source
bias <- 0 # bias 

set.seed(98) # for reproducibility

sim_data <- data.frame() # empty df for storing simulated data


for (trial in 1:n_trials){
  
  Source1 = sample(1:8, 1, replace = TRUE) # sample own source
  w1 = w1
  w2 = w2 
  Bias = bias 
  
  repeat { # repeat until a correct feedback is found
    
    # sample feedback from the feedback list
    feedback_sample <- sample(feedback_options, 1)
    Source2 <- Source1 + feedback_sample # calculate Source2 based on feedback
    
    if (Source2 >= 1 && Source2 <= 8) { # check if Source2 is within the range 
    
      break # exit the repeat loop
      } else {
      # reshuffle the copy of the feedback list for another attempt
      feedback_sample <- sample(feedback_options,1)
    }
  }
  
  # temporary df with the current trial's data
  temp_df <- data.frame(Source1 = Source1, Source2 = Source2, Trial = trial, Bias = bias, w1 = w1, w2 = w2)
  
  # Aapend the temporary df to sim_data
  sim_data <- rbind(sim_data, temp_df)
}

# use agent function to calculate belief (i.e., agent's rating after the break)
for (i in seq(nrow(sim_data))) {
  
  sim_data$Source1[i] <- (sim_data$Source1[i]+1)/10 # scale Source1 to [0,1]
  sim_data$Source2[i] <- (sim_data$Source2[i]+1)/10 # scale Source2 to [0,1]
  
  sim_data$belief[i] <- WeightedBayes_f(sim_data$Bias[i], 
                                         sim_data$Source1[i], 
                                         sim_data$Source2[i],
                                         sim_data$w1[i], 
                                         sim_data$w2[i])
  
  sim_data$binary[i] <- rbinom(1,1,sim_data$belief[i])
  sim_data$continuous[i] <- sim_data$belief[i] * 9
  sim_data$discrete[i] <- round(sim_data$belief[i] * 9)
}

view(sim_data)
```


```{r}
# plot
ggplot(sim_data, aes(Source1, belief, color = Source2, group = Source2)) +
  geom_line() +
  theme_bw() 
```

```{r}
ggplot(sim_data) +
  geom_histogram(aes(belief), alpha = 0.2, color = "purple", fill = "blue") +
  theme_bw()+ 
  # add plot title
  ggtitle("Belief distribution (i.e., distribution of the 3rd choice made") 
```
## Implementing Stan Model
```{r}
stan_WB <- "
data {
  int<lower=0> N; // number of trials
  array[N] int y; // discrete choice
  array[N] real <lower = 0, upper = 1> Source1; // own source
  array[N] real <lower = 0, upper = 1> Source2; // other source 
}

transformed data {
  array[N] real l_Source1; // array of len N with logit of Source1
  array[N] real l_Source2; // array of len N with logit of Source2
  l_Source1 = logit(Source1); // logit of Source1
  l_Source2 = logit(Source2); // logit of Source2
}

parameters {
  real bias; // bias param
  // meaningful weights are btw 0.5 and 1 (theory reasons)
  real<lower = 0.5, upper = 1> w1; // weight for own source real number between 0.5 and 1
  real<lower = 0.5, upper = 1> w2; // weight for other source real number between 0.5 and 1
}

transformed parameters {
  real<lower = 0, upper = 1> weight1; // weight for own source
  real<lower = 0, upper = 1> weight2; // weight for other source
  // weight parameters are rescaled to be on a 0-1 scale (0 -> no effects; 1 -> face value)
  weight1 = (w1 - 0.5) * 2;  // rescale weight1
  weight2 = (w2 - 0.5) * 2;  // rescale weight2 
}

model {
  
  target += normal_lpdf(bias | 0, 1); // prior for bias
  target += beta_lpdf(weight1 | 1, 1); // prior for weight1
  target += beta_lpdf(weight2 | 1, 1); // prior for weight2
  
  for (n in 1:N)
    target += bernoulli_logit_lpmf(y[n] | bias + weight1 *l_Source1[n] + weight2 * l_Source2[n]);
}

generated quantities{
  array[N] real log_lik; // array of len N with log likelihood
  real bias_prior; // prior for bias
  real w1_prior; // prior for weight1
  real w2_prior; // prior for weight2
  bias_prior = normal_rng(0, 1) ; // sample from prior for bias
  w1_prior = 0.5 + inv_logit(normal_rng(0, 1))/2 ; // sample from prior for weight1
  w2_prior = 0.5 + inv_logit(normal_rng(0, 1))/2 ; // sample from prior for weight2
  for (n in 1:N)
    log_lik[n]= bernoulli_logit_lpmf(y[n] | bias + weight1 * l_Source1[n] + weight2 * l_Source2[n]);
}

"

write_stan_file(
  stan_WB,
  dir = "stan/",
  basename = "stan_WB.stan")
```

## Loading stan model

```{r}

file <- file.path("stan/stan_WB.stan")
mod_wb <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE),
                     stanc_options = list("O1"))

```

## Fitting WB on synthetic data 
```{r}
data_weightedBayes <- list(
  N = nrow(sim_data),
  y = sim_data$binary,
  Source1 = sim_data$Source1,
  Source2 = sim_data$Source2
)


samples_weighted <- mod_wb$sample(
  data = data_weightedBayes,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 1500,
  iter_sampling = 3000,
  refresh = 500
)

```
```{r}
samples_weighted$cmdstan_diagnose()
```

```{r}
samples_weighted$summary()
```

```{r}
samples_weighted$loo()
```
```{r}
draws_df <- as_draws_df(samples_weighted$draws())

ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()
```

```{r}
ggplot(draws_df, aes(.iteration, w1, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()
```


```{r}
ggplot(draws_df, aes(.iteration, w2, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()
```


```{r}

library(patchwork)

p1 <- ggplot(draws_df) +
  geom_density(aes(bias, fill = "Posterior"), alpha = 0.6) +
  geom_density(aes(bias_prior, fill = "Prior"), alpha = 0.6) +
  geom_vline(xintercept = sim_data$Bias[1]) +
  theme_bw() +
  labs(title = "Bias Distribution")

p2 <- ggplot(draws_df) +
  geom_density(aes(w1, fill = "Posterior"), alpha = 0.6) +
  geom_density(aes(w1_prior, fill = "Prior"), alpha = 0.6) +
  geom_vline(xintercept = sim_data$w1[1]) +
  theme_bw() +
  labs(title = "Weight 1 Distribution")

p3 <- ggplot(draws_df) +
  geom_density(aes(w2, fill = "Posterior"), alpha = 0.6) +
  geom_density(aes(w2_prior, fill = "Prior"), alpha = 0.6) +
  geom_vline(xintercept = sim_data$w2[1]) +
  theme_bw() +
  labs(title = "Weight 2 Distribution")

# define the colors once and remove the legend from all but one plot
p1 <- p1 + scale_fill_manual(values = c("Posterior" = "lightblue", "Prior" = "pink"), name = "") + theme(legend.position = "none")
p2 <- p2 + scale_fill_manual(values = c("Posterior" = "lightblue", "Prior" = "pink"), name = "") + theme(legend.position = "none")
p3 <- p3 + scale_fill_manual(values = c("Posterior" = "lightblue", "Prior" = "pink"), name = "") # keep the legend in this plot

p1 + p2 + p3 


# use below code to combine the plots in 1 col 3 rows
#combined_plot <- p1 / p2 / p3 + plot_layout(guides = "collect")
#combined_plot

```

```{r}
ggplot(draws_df) +
  geom_point(aes(w1, w2), alpha = 0.3) +
  theme_bw()
```

```{r}
ggplot(draws_df) +
  geom_point(aes(bias, w1), alpha = 0.3) +
  theme_bw()
```

```{r}
ggplot(draws_df) +
  geom_point(aes(bias, w2), alpha = 0.3) +
  theme_bw()
```


## Fitting WB on CogSci data

```{r}
cogsci_file <- file.path("data/sc_df_clean.csv")
cogsci_df <- read_csv(cogsci_file)
```

```{r}
# print column names in cogsci_df
colnames(cogsci_df)
```

```{r}
cols_to_remove <- c("ID", "TimeStamp1","TimeStamp2")

cogsci_df <- cogsci_df %>%
  select(-cols_to_remove)
```

```{r}
cogsci_clean <- cogsci_df %>% filter(GroupRating != 0)
```

```{r}

data_weightedBayes_cogsci <- list(
  N = nrow(cogsci_clean),
  y = (cogsci_clean$SecondRating+1)/10,
  Source1 = (cogsci_clean$FirstRating+1)/10,
  Source2 = (cogsci_clean$GroupRating+1)/10
)


samples_weighted_cogsci <- mod_wb$sample(
  data = data_weightedBayes_cogsci,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 1500,
  iter_sampling = 3000,
  refresh = 500
)
```

```{r}
samples_weighted_cogsci$cmdstan_diagnose()
```

```{r}
samples_weighted_cogsci$summary()
```

```{r}
samples_weighted_cogsci$loo()
```

```{r}
draws_df <- as_draws_df(samples_weighted_cogsci$draws())

ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()
```

```{r}
ggplot(draws_df, aes(.iteration, w1, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()
```

```{r}
ggplot(draws_df, aes(.iteration, w2, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()
```

```{r}

library(patchwork)

p1 <- ggplot(draws_df) +
  geom_density(aes(bias, fill = "Posterior"), alpha = 0.6) +
  geom_density(aes(bias_prior, fill = "Prior"), alpha = 0.6) +
  theme_bw() +
  labs(title = "Bias Distribution")

p2 <- ggplot(draws_df) +
  geom_density(aes(w1, fill = "Posterior"), alpha = 0.6) +
  geom_density(aes(w1_prior, fill = "Prior"), alpha = 0.6) +
  theme_bw() +
  labs(title = "Weight 1 Distribution")

p3 <- ggplot(draws_df) +
  geom_density(aes(w2, fill = "Posterior"), alpha = 0.6) +
  geom_density(aes(w2_prior, fill = "Prior"), alpha = 0.6) +
  theme_bw() +
  labs(title = "Weight 2 Distribution")

# define the colors once and remove the legend from all but one plot
p1 <- p1 + scale_fill_manual(values = c("Posterior" = "lightblue", "Prior" = "pink"), name = "") + theme(legend.position = "none")
p2 <- p2 + scale_fill_manual(values = c("Posterior" = "lightblue", "Prior" = "pink"), name = "") + theme(legend.position = "none")
p3 <- p3 + scale_fill_manual(values = c("Posterior" = "lightblue", "Prior" = "pink"), name = "") # keep the legend in this plot

p1 + p2 + p3 


# use below code to combine the plots in 1 col 3 rows
#combined_plot <- p1 / p2 / p3 + plot_layout(guides = "collect")
#combined_plot

```

```{r}
ggplot(draws_df) +
  geom_point(aes(w1, w2), alpha = 0.3) +
  theme_bw()
```

```{r}
ggplot(draws_df) +
  geom_point(aes(bias, w1), alpha = 0.3) +
  theme_bw()
```

```{r}
ggplot(draws_df) +
  geom_point(aes(bias, w2), alpha = 0.3) +
  theme_bw()
```


## Simulate weighted bayes with a grid

```{r Trying to simulate data with a grid}
# Global parameters
n_trials <- 150
feedback_options <- c(-3, -2, 0, 2, 3) # Feedback options 
bias <- 0 # Bias 

set.seed(98) # For reproducibility

# Create a grid of w1 and w2 values
w_values <- seq(0.5, 1, by = 0.1)
weights_grid <- expand.grid(w1 = w_values, w2 = w_values)

# Empty data frame for storing simulated data
sim_data <- data.frame()

# Iterate over each combination of w1 and w2
for (idx in 1:nrow(weights_grid)) {
  w1 <- weights_grid$w1[idx]
  w2 <- weights_grid$w2[idx]
  
  for (trial in 1:n_trials) {
    
    Source1 <- sample(1:8, 1, replace = TRUE) # Sample own source
    Bias <- bias
    
    repeat { # Repeat until a correct feedback is found
      
      # Sample feedback from the feedback list
      feedback_sample <- sample(feedback_options, 1)
      Source2 <- Source1 + feedback_sample # Calculate Source2 based on feedback
      
      if (Source2 >= 1 && Source2 <= 8) { # Check if Source2 is within the range
        break # Exit the repeat loop
      }
    }
    
    # Calculate belief using the WeightedBayes function
    scaled_Source1 <- (Source1 + 1) / 10
    scaled_Source2 <- (Source2 + 1) / 10
    belief <- WeightedBayes_f(Bias, scaled_Source1, scaled_Source2, w1, w2)
    
    # Temporary df with the current trial's data
    temp_df <- data.frame(Trial = trial, Source1 = Source1, Source2 = Source2, 
                          Bias = Bias, w1 = w1, w2 = w2, Belief = belief)
    
    # Append the temporary df to sim_data
    sim_data <- rbind(sim_data, temp_df)
  }
}

```


